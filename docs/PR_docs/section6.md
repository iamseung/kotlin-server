### [필수] Distributed Lock

- 과제 내용
  1. Redis 기반의 분산락을 직접 구현해보고 동작에 대한 통합 테스트 작성
  2. 주문/예약/결제 기능 등에 (1) 적절한 키 (2) 적절한 범위를 선정해 분산락을 적용

- 주요 평가 기준
  1. 분산락에 대한 이해와 DB Transaction 과 혼용할 때 주의할 점을 이해하였는지
  2. 적절하게 분산락이 적용되는 범위에 대한 구현을 진행하였는지

### [선택] Cache
- 과제 내용
  1. 조회가 오래 걸리거나, 자주 변하지 않는 데이터 등 애플리케이션의 요청 처리 성능을 높이기 위해 캐시 전략을 취할 수 있는 구간을 점검하고, 적절한 캐시 전략을 서정
  2. 위 구간에 대해 Redis 기반의 캐시 전략을 시나리오에 적용하고 성능 개선 등을 포함한 보고서 작성 및 제출

- 주요 평가 기준
  1. 각 시나리오에서 발생하는 Query에 대한 충분한 이해가 있는지
  2. 각 사나리오에서 캐시 가능한 구간을 분석하였는지
  3. 대량의 트래픽 발생시 지연이 발생할 수 있는 조회쿼리에 대해 분석하고, 이에 대한 결과를 작성하였는지

---

# [필수] 분산락 구현

## 1. 구현 방식

- **Redisson** 채택 (자체 분산락 기능 지원)
- `DistributeLockExecutor` 인터페이스 + `RedisDistributeLockExecutor` 구현체
- `TransactionExecutor`로 Self-invocation 문제 해결

## 2. 핵심 원칙

### 분산락 > 트랜잭션 순서 (⭐ 가장 중요)

```kotlin
distributeLockExecutor.execute {      // 1. 락 획득
    transactionExecutor.execute {      // 2. 트랜잭션 시작
        // 비즈니스 로직
    }                                  // 3. 트랜잭션 커밋
}                                      // 4. 락 해제
```

> ❌ 순서가 바뀌면 트랜잭션 커밋 전 락 해제 → Dirty Read 가능

### 적용 전략

| 전략 | 설명 |
|------|------|
| **빠른 실패** | 검증 로직은 락 밖에서 실행 → 잘못된 요청은 락 획득 안 함 |
| **TOCTOU 방지** | 락 밖 사전검증 + 트랜잭션 내 재검증 |
| **READ/WRITE 분리** | READ는 락 밖, WRITE만 락 안에서 |

## 3. UseCase별 적용

| UseCase | 락 키 | 적용 범위 |
|---------|-------|----------|
| 포인트 충전 | `point:lock:{userId}` | 포인트 충전 + 히스토리 기록 |
| 좌석 예약 | `seat:lock:{scheduleId}-{seatId}` | 좌석 변경 + 예약 생성 + 토큰 만료 |
| 결제 처리 | `reservation:payment:lock:{reservationId}` | 포인트 차감 + 결제 생성 + 좌석/예약 상태 변경 |

## 4. 성능 개선

| 지표 | Before | After | 개선 |
|------|--------|-------|------|
| 락 보유 시간 | 200ms | 115ms | **43% 감소** |
| 처리량 (TPS) | 5 req/sec | 8.7 req/sec | **74% 증가** |

---

# [선택] Cache 구현

## 1. 캐시 적용 구간 분석

| 조회 구간 | 변경 빈도 | 조회 빈도 | 캐시 적용 | TTL |
|-----------|----------|----------|----------|-----|
| 콘서트 목록 | 매우 낮음 | 매우 높음 | ✅ | 1시간 |
| 콘서트 일정 | 낮음 | 높음 | ✅ | 30분 |
| 좌석 조회 | 높음 | 매우 높음 | ✅ | 10초 |
| 사용자 포인트 | 높음 | 중간 | ❌ | - |
| 예약 상태 | 높음 | 낮음 | ❌ | - |

## 2. 캐시 전략

- **패턴**: Cache Aside (Look-Aside)
- **무효화**: 상태 변경 시 즉시 캐시 삭제

```
Cache HIT  → Redis에서 즉시 반환
Cache MISS → DB 조회 → 캐시 저장 → 반환
```

## 3. 캐시 서비스

| 서비스 | 캐시 키 | TTL | 무효화 시점 |
|--------|--------|-----|------------|
| `ConcertCacheService` | `concerts:all` | 1시간 | 콘서트 정보 변경 시 |
| `ConcertScheduleCacheService` | `concert:schedules:{id}` | 30분 | 일정 변경 시 |
| `SeatCacheService` | `concert:seats:{scheduleId}` | 10초 | 예약/취소/결제 시 |

## 4. 성능 테스트 결과

| 지표 | 캐시 미적용 | 캐시 적용 | 개선율 |
|------|-----------|----------|--------|
| 좌석 조회 응답시간 | ~50-100ms | ~5-15ms | **70-90%** |
| DB 쿼리 수 (100 req) | 100회 | 1회 | **99%** |
| 100회 조회 총 시간 | ~3-5초 | ~0.5-1초 | **70-80%** |

## 5. 대량 트래픽 시나리오

**인기 콘서트 티켓팅 (10,000명 동시 접속)**

```
캐시 미적용: 10,000 req × DB 조회 → Connection Pool 고갈 → 서비스 장애
캐시 적용:   1회 DB 조회 + 9,999회 Redis → DB 부하 99.99% 감소
```

---

# 결론

## [필수] 분산락
- ✅ Lock → Transaction 순서 이해 및 적용
- ✅ 도메인별 최적 락 키 설계
- ✅ 성능 최적화 (READ/WRITE 분리, 빠른 실패)

## [선택] Cache
- ✅ 시나리오별 Query 분석 및 캐시 적합성 판단
- ✅ 변경 빈도에 따른 TTL 차등 설정
- ✅ 대량 트래픽 시 성능 개선 효과 측정
